const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-toolbox/network-helpers");


describe("FreelanceEscrow", function() {
    let escrow;
    let owner, freelancer, client;

beforeEach(async function() {
    [owner, freelancer, client] = await ethers.getSigners();
    const FreelanceEscrow = await ethers.getContractFactory("FreelanceEscrow");
    escrow = await FreelanceEscrow.deploy();
    await escrow.waitForDeployment();
});

async function createBasicDeal() {
    await escrow.connect(client).createDeal(
        freelancer.address,
        7 * 24 * 60 * 60,
        { value: ethers.parseEther("1") }
    );
}
async function createAndApproveDeal() {
    await createBasicDeal();
    await escrow.connect(client).approveWork(1);

}

//createDeal
it("should revert if freelancer address is zero", async function() {
    await expect (
        escrow.connect(client).createDeal(
            ethers.ZeroAddress,
            7 * 24 * 60 * 60,
        { value: ethers.parseEther("1") }
        )
    ).to.be.revertedWithCustomError(escrow, "InvalidAddress")
});
it("should revert if the sent amount is zero", async function() {
    await expect(
        escrow.connect(client).createDeal(
            freelancer.address,
            7 * 24 * 60 * 60,
            { value: 0 }
        )
    ).to.be.revertedWithCustomError(escrow,"InvalidAmount");
});
it("should create a deal correctly with valid inputs", async function() {
    const tx = await escrow
    .connect(client)
    .createDeal(freelancer.address, 7 * 24 * 60 * 60, {
        value: ethers.parseEther("1"),
        });

        await expect(tx).to.emit(escrow, "DealCreated"); 

        const deal = await escrow.deals(1);
        expect(deal.client).to.equal(client.address);
        expect(deal.freelancer).to.equal(freelancer.address);
        expect(deal.amount).to.equal(ethers.parseEther("1"));
        expect(deal.approved).to.equal(false);
        expect(deal.paid).to.equal(false);

        const now = await time.latest();
        expect(Number(deal.workDeadline)).to.be.greaterThan(now);
        expect(Number(deal.releaseTime)).to.be.greaterThan(now);    
});

//approveWork
it("should revert if deal Id is invalid", async function() {
    await expect(
        escrow.connect(client).approveWork(99),
    ).to.be.revertedWithCustomError(escrow,"InvalidId");
});
it("should revert if the deal Id is zero", async function() {
    await expect(
        escrow.connect(client).approveWork(0),
    ).to.be.revertedWithCustomError(escrow, "InvalidId");
});
it("should revert if the user is not authorized to approve the work", async function(){
    await createBasicDeal();
    
    await expect(
        escrow.connect(freelancer).approveWork(1)
    ).to.be.revertedWithCustomError(escrow,"NotAuthorized");
});
it("should approve the deal correctly", async function(){
     await createBasicDeal();

      const tx =  await escrow.connect(client).approveWork(1);
      await expect(tx).to.emit(escrow, "DealApproved");

      const deal = await escrow.deals(1);
      expect(deal.approved).to.equal(true);
});
it("should revert if the client tries to approve an already approved deal",async function(){
    await createAndApproveDeal();
    await expect(
        escrow.connect(client).approveWork(1)
    ).to.be.revertedWithCustomError(escrow,"AlreadyApproved");
});

//releasePayment
it("should release the payment correctly",async function() {
    await createAndApproveDeal();
    await time.increase(14 * 24 * 60 * 60);
    

    const beforeBalance = await ethers.provider.getBalance(freelancer.address);
    await escrow.connect(freelancer).releasePayment(1);
    const afterBalance = await ethers.provider.getBalance(freelancer.address);

    expect(afterBalance).to.be.greaterThan(beforeBalance);

    const deal = await escrow.deals(1);
    expect(deal.paid).to.equal(true);
});
it("should revert if the freelancer tries to release the payment too early", async function() {
    await createAndApproveDeal();
    await expect (
        escrow.connect(freelancer).releasePayment(1)
    ).to.be.revertedWithCustomError(escrow, "TimeIsLocked");
});
it("should revert if the freelancer tries to release the payment when the deal is not approved", async function(){
    await createBasicDeal();
  
    await expect (
        escrow.connect(freelancer).releasePayment(1)
    ).to.be.revertedWithCustomError(escrow, "NotApproved");
});
it("should revert if a non-freelancer tries to release the payment", async function(){
    await createAndApproveDeal();
    await time.increase(14 * 24 * 60 * 60);
    await expect (
        escrow.connect(client).releasePayment(1)
    ).to.be.revertedWithCustomError(escrow, "NotAuthorized");
});
it("should revert if the freelancer tries to release a deal that is already paid", async function(){
    await createAndApproveDeal();
    await time.increase(14 * 24 * 60 * 60);
    await escrow.connect(freelancer).releasePayment(1);
    await expect (
        escrow.connect(freelancer).releasePayment(1)
    ).to.be.revertedWithCustomError(escrow, "AlreadyPaid");
});

//cancelDeal
it("should allow the client to cancel the deal correctly", async function() {
    await createBasicDeal();
    await time.increase(8 * 24 * 60 * 60);
    const tx = await escrow.connect(client).cancelDeal(1);
    await expect(tx).to.emit(escrow, "CancelDeal"); 
    const deal = await escrow.deals(1);
    expect(deal.paid).to.equal(true);
});
it("should revert if a non-client tries to cancel the deal", async function(){
    await createBasicDeal();
    await time.increase(8 * 24 * 60 * 60);
    await expect (
        escrow.connect(freelancer).cancelDeal(1)
    ).to.be.revertedWithCustomError(escrow,"NotAuthorized");
});
it("should revert if the client tries to cancel an already paid or approved deal", async function(){
    await createAndApproveDeal();
    await time.increase(15 * 24 * 60 * 60);
    await escrow.connect(freelancer).releasePayment(1);
    await expect (
        escrow.connect(client).cancelDeal(1)
    ).to.be.revertedWithCustomError(escrow, "AlreadyApproved");
});
it("should revert if the client tries to cancel the deal before the deadline has passed", async function(){
    await createBasicDeal();
    await expect(
        escrow.connect(client).cancelDeal(1)
    ).to.be.revertedWithCustomError(escrow, "TimeNotFinished");
});

//raiseDispute
it("should revert if the dispute is raised by someone other than the client or freelancer",async function(){
    await createAndApproveDeal();
    await time.increase(15 * 24 * 60 * 60);
    await expect(
        escrow.connect(owner).raiseDispute(1, "reason")
    ).to.be.revertedWithCustomError(escrow, "NotAuthorized");
});
it("should revert if someone tries to raise a dispute for an already paid deal", async function(){
    await createAndApproveDeal();
    await time.increase(15 * 24 * 60 * 60);
    await escrow.connect(freelancer).releasePayment(1);
    await expect(
        escrow.connect(client).raiseDispute(1, "reason")
    ).to.be.revertedWithCustomError(escrow, "AlreadyPaid");
});
it("should raise a dispute correctlyy", async function(){
    await createAndApproveDeal();
    await time.increase(15 * 24 * 60 * 60);

    const tx =  await escrow.connect(freelancer).raiseDispute(1, "reason");
    await expect(tx).to.emit(escrow, "DisputeRaised");
    const deal = await escrow.deals(1);
    expect(deal.disputed).to.equal(true);
    expect(deal.disputeReason).to.equal("reason");
    expect(deal.arbitrator).to.equal(owner.address);
});

//resolveDispute
it("should revert if the function is called by someone other than the owner", async function() {
    await createAndApproveDeal();
    await time.increase(15 * 24 * 60 * 60);
    await escrow.connect(freelancer).raiseDispute(1, "reason"); // Створюємо спір
    await expect(
        escrow.connect(client).resolveDispute(1, true)
    ).to.be.revertedWith("Ownable: caller is not the owner");
    await expect(
        escrow.connect(freelancer).resolveDispute(1, true)
    ).to.be.revertedWith("Ownable: caller is not the owner");
});
it("should revert if trying to resolve a deal that has no dispute", async function(){
    await createAndApproveDeal();
    await time.increase(15 * 24 * 60 * 60);
    await expect(
        escrow.connect(owner).resolveDispute(1, true)
    ).to.be.revertedWithCustomError(escrow, "NotDisputed");
});
it("should revert if trying to resolve a dispute for an already paid deal", async function(){
    await createAndApproveDeal();
    await escrow.connect(freelancer).raiseDispute(1, "reason");
    await time.increase(15 * 24 * 60 * 60);
    await escrow.connect(freelancer).releasePayment(1);
    await expect(
        escrow.connect(owner).resolveDispute(1, true)
    ).to.be.revertedWithCustomError(escrow, "AlreadyPaid");
});
it("should resolve the dispute correctly and transfer funds to the client", async function(){
  await createAndApproveDeal();
  await time.increase(15 * 24 * 60 * 60);
  await escrow.connect(freelancer).raiseDispute(1, "reason");

  const beforeBalance = await ethers.provider.getBalance(client.address);
  const tx = await escrow.connect(owner).resolveDispute(1, true);
  await expect(tx).to.emit(escrow, "DisputeResolved");

  const afterBalance = await ethers.provider.getBalance(client.address);
  expect(afterBalance).to.be.greaterThan(beforeBalance);
});

//pause/unpause
it("should revert if pause is called by non-owner", async function () {
        await expect(
            escrow.connect(client).pause()
        ).to.be.revertedWith("Ownable: caller is not the owner");
        await expect(
            escrow.connect(freelancer).pause()
        ).to.be.revertedWith("Ownable: caller is not the owner");
});

    it("should revert if unpause is called by non-owner", async function () {
        await escrow.connect(owner).pause();
        await expect(
            escrow.connect(client).unpause()
        ).to.be.revertedWith("Ownable: caller is not the owner");
        await expect(
            escrow.connect(freelancer).unpause()
        ).to.be.revertedWith("Ownable: caller is not the owner");
});
    it("should pause and unpause contract correctly", async function () {
        await escrow.connect(owner).pause();
        await expect(
            escrow.connect(client).createDeal(freelancer.address, 7 * 24 * 60 * 60, {
                value: ethers.parseEther("1"),
            })
        ).to.be.revertedWith("Pausable: paused");
        await escrow.connect(owner).unpause();
        await expect(
            escrow.connect(client).createDeal(freelancer.address, 7 * 24 * 60 * 60, {
                value: ethers.parseEther("1"),
            })
        ).to.not.be.reverted;
        const deal = await escrow.deals(1);
        expect(deal.client).to.equal(client.address);
});
});






