const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-toolbox/network-helpers");

describe("SubscriptionService", function() {
    let user1;
    let subscript;

beforeEach(async function() {
    [user1] = await ethers.getSigners();
    const SubscriptionService = await ethers.getContractFactory("SubscriptionService");
    subscript = await SubscriptionService.deploy(ethers.parseEther("1"));
    await subscript.waitForDeployment();
});
it("should create new subscription and store data in mapping", async function(){

    const now = await time.latest();
    const timeEnd = now + 30 * 24 * 60 * 60;

    await expect(
    subscript.connect(user1).subscribe({ value: ethers.parseEther("1") })
    ).to.emit(subscript, "Subscribed");

    const sub = await subscript.subscriptions(user1.address, 0);

expect(sub.user).to.equal(user1.address);
expect(sub.status).to.equal(true);
expect(Number(sub.timeStart)).to.be.closeTo(Number(now), 5);
expect(Number(sub.timeEnd)).to.be.closeTo(Number(timeEnd), 5);
});

it("should revert when send invalid price", async function() {
    const price = await subscript.price();

    await expect(
        subscript.connect(user1).subscribe({
             value: price - ethers.parseEther("1")})
            ).to.be.revertedWithCustomError(subscript, "InvalidPaymentAmount");
    await expect(
        subscript.connect(user1).subscribe({
            value: price + ethers.parseEther("1")})
            ).to.be.revertedWithCustomError(subscript, "InvalidPaymentAmount");

})

it("should revert if user not has subscribed", async function() {
    await expect(
    subscript.connect(user1).renew({
        value: ethers.parseEther("1") })
    ).to.be.revertedWithCustomError(subscript, "NoSubscriptionToRenew")
})

it("should revert if user already has subscription", async function() {
    const now = await time.latest();
    const timeEnd = now + 30 * 24 * 60 * 60;

    await expect(
    subscript.connect(user1).subscribe({ value: ethers.parseEther("1") })
    ).to.emit(subscript, "Subscribed");

     await expect(
    subscript.connect(user1).renew({
        value: ethers.parseEther("1") })
    ).to.be.revertedWithCustomError(subscript, "HasSubscription")
})
it("should renew subscribe", async function() {
    const now = await time.latest();
    const timeEnd = now + 30 * 24 * 60 * 60;

    await expect(
    subscript.connect(user1).subscribe({ value: ethers.parseEther("1") })
    ).to.emit(subscript, "Subscribed");

    await time.increase(31 * 24 * 60 * 60);;

    await expect(
    subscript.connect(user1).renew({
        value: ethers.parseEther("1") })
    ).to.emit(subscript, "Subscribed");



    const firstSub = await subscript.subscriptions(user1.address, 0);
    const secondSub = await subscript.subscriptions(user1.address, 1);

    
    expect(secondSub.status).to.equal(true);
    expect(firstSub.status).to.equal(false);



})


})


