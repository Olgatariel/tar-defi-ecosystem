const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-toolbox/network-helpers");

describe("TimeLockedWallet", function() {
    let locker;
    let user1;

beforeEach(async function() {
    [user1] = await ethers.getSigners();
    const TimeLockedWallet = await ethers.getContractFactory("TimeLockedWallet");
    locker = await TimeLockedWallet.deploy();
    await locker.waitForDeployment();
});
it("should create deposit correctly and store data in mapping", async function (){
    const unlockTime = (await time.latest()) + 3600;
    await expect(
    locker.connect(user1).createDeposit(unlockTime, { value: ethers.parseEther("1") })
    ).to.emit(locker, "DepositCreated")
    .withArgs(user1.address, ethers.parseEther("1"), unlockTime);

    const dep = await locker.allDeposits(user1.address, 0);
    expect(dep.depositSum).to.equal(ethers.parseEther("1"));
    expect(dep.unlockTime).to.equal(unlockTime);
    expect(dep.active).to.equal(true);
   

    const balance = await ethers.provider.getBalance(locker.target);
    expect(balance).to.equal(ethers.parseEther("1"));
});
it("should revert when the time is still locked", async function (){
    const unlockTime = (await time.latest()) + 3600;
    await expect(
        locker.connect(user1).createDeposit(unlockTime, { value: ethers.parseEther("1") })
    ).to.emit(locker, "DepositCreated")
    .withArgs(user1.address, ethers.parseEther("1"), unlockTime);

    const dep = await locker.allDeposits(user1.address, 0);
    expect(dep.depositSum).to.equal(ethers.parseEther("1"));
    expect(dep.unlockTime).to.equal(unlockTime);
    expect(dep.active).to.equal(true);

    await expect(
        locker.connect(user1).withdrawDeposit(0)
    ).to.be.revertedWithCustomError(locker, "StillLocked"); 
});
it("should withdrawn correctly when the time unlock", async function() {
    const unlockTime = (await time.latest()) + 3600;
    await expect(
        locker.connect(user1).createDeposit(unlockTime, { value: ethers.parseEther("1") })
    ).to.emit(locker, "DepositCreated")
    .withArgs(user1.address, ethers.parseEther("1"), unlockTime);

    await time.increaseTo(unlockTime);
    console.log(await time.latest());

    await expect(
        locker.connect(user1).withdrawDeposit(0)
    ).to.emit(locker, "Withdrawn")
    .withArgs(user1.address, ethers.parseEther("1"), 0);

    const balance = await ethers.provider.getBalance(locker.target);
    expect(balance).to.equal(0);

    console.log(await ethers.provider.getBalance(user1.address));
    console.log(await ethers.provider.getBlock("latest"));
});
it("should revert if trying to withdraw again (AlreadyWithdrawn)", async function() {
    const unlockTime = (await time.latest()) + 3600;
    await expect(
        locker.connect(user1).createDeposit(unlockTime, { value: ethers.parseEther("1") })
    ).to.emit(locker, "DepositCreated")
    .withArgs(user1.address, ethers.parseEther("1"), unlockTime);

    await time.increaseTo(unlockTime);
    console.log(await time.latest());

    await expect(
        locker.connect(user1).withdrawDeposit(0)
    ).to.emit(locker, "Withdrawn")
    .withArgs(user1.address, ethers.parseEther("1"), 0);

    await expect(
        locker.connect(user1).withdrawDeposit(0)
    ).to.be.revertedWithCustomError(locker, "AlreadyWithdrawn");

});
})